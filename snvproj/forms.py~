from django import forms
from django.core.exceptions import ValidationError # ex. for email validation
 
from django.db.models import Q
from simple_search import BaseSearchForm
from snv.models import Uniprot #, MyCategory , and others


class UniprotSearchForm(BaseSearchForm):

	class Meta:
		base_qs = Uniprot.objects #query to search
		search_fields = ('^name', 'description', 'specifications', '=id')   #The fields to search, using the same syntax as the django admin directive of the same name, ie.
											# 'fieldname' - field must contain the search string
											# '^fieldname' - field must start with the search string
											# '=fieldname' - field must exactly equal the search string
											# '@fieldname' - performs a fulltext search (mysql/postgres only) on field


		# assumes a fulltext index has been defined on the fields
		# 'name,description,specifications,id'
		fulltext_indexes = (
                    ('name', 2), # name matches are weighted higher
                    ('name,description,specifications,id', 1),
                )

    """ 
    A custom addition - the absence of a prepare_category method means
    the query will search for an exact match on this field.
    """
	category = forms.ModelChoiceField(
                queryset = MyCategory.objects.all(),
                required = False
        )

    """ 
    This field creates a custom query addition via the prepare_start_date
    method.
    """
'''	start_date = forms.DateField(
                required = False,
                input_formats = ('%Y-%m-%d',),
        )
	def prepare_start_date(self):
		if self.cleaned_data['start_date']:
			return Q(creation_date__gte=self.cleaned_data['start_date'])
		else:
			return ""

'''
'''
class ContactForm(forms.ModelForm):

	confirm_email = forms.EmailField(
        "Confirm email",
        required=True,
    )

	class Meta:
		model = Contact

	def __init__(self, *args, **kwargs):
		if kwargs.get('instance'):
			email = kwargs['instance'].email
			kwargs.setdefault('initial', {})['confirm_email'] = email
		return super(ContactForm, self).__init__(*args, **kwargs)
		
	def clean(self):
		if (self.cleaned_data.get('email') != self.cleaned_data.get('confirm_email')):
			#self.add_error("Email addresses must match.")
			raise ValidationError("Email addresses must match.")
		return self.cleaned_data


		
from django.forms.models import inlineformset_factory

from contacts.models import ( Contact, Address,)

# inlineformset_factory creates a Class from a parent model (Contact)
# to a child model (Address)
ContactAddressFormSet = inlineformset_factory(Contact,Address,)

'''
